#version 330 core
precision highp float;
#define MAX_MODEL_PER_DRAW 200

// light property
uniform vec4 mtlAmbientColor;
uniform vec4 mtlDiffuseColor;
uniform vec4 mtlSpecularColor;
uniform float mtlSpecularExponent;

in vec2 text_coord;

// for texture
uniform sampler2D colorText;
uniform sampler2D posText;
uniform sampler2D normalText;
uniform int lightNum;
uniform mat4 pvMatrix;
uniform vec3 sunPos;
uniform vec3 lookto;
uniform int drawSun;
uniform vec3 backColor;

// for selection
in float downParam;
in vec3 scrPos;

// reflection
uniform float alpha;

// out color
out vec4 oColor;

// gbuffer
//in vec3 lightPos;

void main() {
    // 获取颜色
    const float lightDotSize = 0.5;
    vec4 color = texture2D(colorText, text_coord) * 2;
    vec3 pos = vec3(texture2D(posText, text_coord)).rgb;
    vec3 normal = vec3(texture2D(normalText, text_coord)).rgb;

    float factor = 0.0f;
    vec3 lightDir = normalize(sunPos - pos);
    factor = max(dot(normalize(normal), lightDir), 0.0);

    vec4 lightScr = pvMatrix * vec4(sunPos, 1.0);
    lightScr = lightScr / lightScr.w;
    vec4 fPos = pvMatrix * vec4(pos, 1.0);
    fPos = fPos / fPos.w;
    if (drawSun > 0) {
        oColor = vec4(backColor, 1.0);
        if ((lookto.y > 0.0) && (length(lightScr.xy - scrPos.xy) < lightDotSize)) {
            factor = (lightDotSize - length(lightScr.xy - scrPos.xy)) / lightDotSize;
            float alphax = pow(factor, 6.0);
            oColor = (1.2 * vec4(1.0, 225.0f/255.0f, 0.65f, 1.0f)) * alphax + oColor * (1.0 - alphax);
//            oColor = min(oColor, vec4(1.0, 215.0f/255.0f, 1.0f, 1.0f));
            oColor = clamp(oColor, 0.0, 1.0);
            oColor.w = 1.0;
        }
    } else {
        oColor = color * 0.3 + (color * clamp(factor, 0.0, 0.5));
        oColor.w = 1.0f;
    }
}
